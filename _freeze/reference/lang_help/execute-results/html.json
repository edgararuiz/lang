{
  "hash": "ce7c0f337d48aa8edf36afbd5f6f4ad4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Translates help\"\nexecute:\n  eval: true\n  freeze: true\n---\n\n\n\n\n## lang_help\n\n## Description\n Translates a given topic into a target language. It uses the `lang` argument to determine which language to translate to. If not passed, this function will look for a target language in the LANG and LANGUAGE environment variables to determine the target language. If the target language is English, no translation will be processed, so the help returned will be the original package's documentation. \n\n\n## Usage\n```r\n \nlang_help(topic, package = NULL, lang = NULL, type = getOption(\"help_type\")) \n```\n\n## Arguments\n|Arguments|Description|\n|---|---|\n| topic | The topic to search for |\n| package | The R package to look for the topic |\n| lang | Language to translate the help to |\n| type | Produce \"html\" or \"text\" output for the help. It default to `getOption(\"help_type\")` |\n\n\n\n## Value\n Returns either a text or html version of the topic's help documentation \n\n\n## Examples\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lang) \nllm_use(\"ollama\", \"llama3.2\", .silent = TRUE) \nlang_help(\"llm_classify\", \"mall\", lang = \"french\") \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTranslating: \n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nTranslating: Title\nTranslating: Title\nTranslating: Title\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n_\bC_\ba_\bt_\bé_\bg_\bo_\br_\bi_\bs_\be_\br _\bl_\be_\bs _\bd_\bo_\bn_\bn_\bé_\be_\bs _\bc_\bo_\bm_\bm_\be _\bl'_\bu_\bn_\be _\bd_\be_\bs _\bo_\bp_\bt_\bi_\bo_\bn_\bs _\bp_\br_\bo_\bp_\bo_\bs_\bé_\be_\bs.'\n\n_\bD_\be_\bs_\bc_\br_\bi_\bp_\bt_\bi_\bo_\bn:\n\n     Utilisez un grand modèle de langage (MLG) pour classer le texte\n     fourni comme l'une des options proposées via la commande\n     'labels'.'\n\n_\bU_\bs_\ba_\bg_\be:\n\n     llm_classify(\n       .data,\n       col,\n       labels,\n       pred_name = \".classify\",\n       additional_prompt = \"\"\n     )\n     \n     llm_vec_classify(x, labels, additional_prompt = \"\", preview = FALSE)\n     \n_\bA_\br_\bg_\bu_\bm_\be_\bn_\bt_\bs:\n\n   .data: Objet de type 'data.frame' ou 'tbl' qui contient le texte à\n          analyser\n\n     col: Le nom du champ à analyser, supporte 'tidy-eval'.\n\n  labels: Un vecteur de caractères avec au moins 2 étiquettes pour\n          classer le texte en fonction de ses catégories.\n\npred_name: Nom du nouveau champ de colonne où la prédiction sera placée\n\nadditional_prompt: \"Introduire ce texte dans le message envoyé au\n          modèle LLM.\"\n\n       x: Vector de texte à analyser\n\n preview: Il renvoie le R appeler qui aurait été utilisé pour exécuter\n          la prédiction. Seul renvoie la première entrée de 'x'. Par\n          défaut, il est fixé à 'FALSY'. Applique uniquement aux\n          fonctions vectorielles.\n\n_\bV_\ba_\bl_\bu_\be:\n\n     'llm_classify' renvoie un objet 'data.frame' ou 'tbl.'\n     'llm_vec_classify' renvoie une vecteur qui est de la même longueur\n     que 'x'.\n\n_\bE_\bx_\ba_\bm_\bp_\bl_\be_\bs:\n\n     library(mall)\n     \n     data(\"reviews\")\n     \n     llm_use(\"ollama\", \"llama3.2\", seed = 100, .silent = TRUE)\n     \n     llm_classify(reviews, review, c(\"appliance\", \"computer\"))\n     \n     # Use 'pred_name' to customize the new column's name\n     llm_classify(\n       reviews,\n       review,\n       c(\"appliance\", \"computer\"),\n       pred_name = \"prod_type\"\n     )\n     \n     # Pass custom values for each classification\n     llm_classify(reviews, review, c(\"appliance\" ~ 1, \"computer\" ~ 2))\n     \n     # For character vectors, instead of a data frame, use this function\n     llm_vec_classify(\n       c(\"this is important!\", \"just whenever\"),\n       c(\"urgent\", \"not urgent\")\n     )\n     \n     # To preview the first call that will be made to the downstream R function\n     llm_vec_classify(\n       c(\"this is important!\", \"just whenever\"),\n       c(\"urgent\", \"not urgent\"),\n       preview = TRUE\n     )\n     \n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}